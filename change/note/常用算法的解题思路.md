# 算法的解题套路

## 递归/回溯：

递归/回溯算法的解题套路是将问题分解为子问题，然后通过递归/回溯的方式分别解决子问题。递归/回溯算法的实现通常需要定义一个递归函数，并在函数中进行子问题的拆解和求解。常见的题目包括斐波那契数列、全排列、组合等。

## 动态规划：

动态规划算法的解题套路是将问题分解为子问题，并将子问题的解缓存起来，以便下次使用。通常需要定义一个状态转移方程，来描述问题的解和子问题的关系。常见的题目包括最长公共子序列、最长上升子序列、背包问题等。

## 贪心算法：

贪心算法的解题套路是通过贪心策略，即每次都在当前状态下选择最优解，来达到全局最优解。贪心算法通常需要证明其正确性，并且需要选择适当的贪心策略。常见的题目包括跳跃游戏、分发糖果、区间调度等。

## 双指针算法：

双指针算法的解题套路是通过维护两个指针，分别指向问题的起始和结束位置，来解决问题。双指针算法通常需要定义指针的移动规则，并且需要证明其正确性。常见的题目包括两数之和、反转字符串、三数之和等。

## 分治算法：

分治算法的解题套路是将问题分解为多个子问题，分别解决子问题，然后将子问题的解合并起来，得到原问题的解。分治算法通常需要定义子问题的分割方式和合并方式，并且需要证明其正确性。常见的题目包括归并排序、快速排序、求众数等。

## 图/树相关算法：

图/树相关算法的解题套路是通过对问题所在的图/树进行遍历、搜索、剪枝等操作，来解决问题。常见的算法包括深度优先搜索、广度优先搜索、拓扑排序、最短路径算法、最小生成树算法等。

# 二进制加减乘除

Java中可以使用位运算来实现二进制加减乘除运算。具体实现如下：

## 二进制加法

二进制加法可以使用上述的位运算实现。假设需要对两个二进制数a和b进行加法运算，可以使用如下代码：
```java
int result = 0; // 存储计算结果
int carry = 0; // 存储进位结果
while (b != 0) {
result = a ^ b; // 不进位的结果
carry = (a & b) << 1; // 进位的结果
a = result;
b = carry;
}
System.out.println(a); // 输出计算结果
```
## 二进制减法

二进制减法可以先将减数按位取反，然后加上1，最后进行二进制加法。具体实现如下：
```java
int negate = ~b + 1; // 取反加1
int result = a + negate; // 二进制加法
System.out.println(result); // 输出计算结果
```
## 二进制乘法
二进制乘法可以使用位运算中的左移运算（<<）和按位与运算（&）实现。假设需要对两个二进制数a和b进行乘法运算，可以使用如下代码：
```java
int result = 0; // 存储计算结果
while (b != 0) {
if ((b & 1) == 1) { // 如果b的最低位是1
result += a; // 将a加到计算结果中
}
a <<= 1; // 左移一位
b >>= 1; // 右移一位
}
System.out.println(result); // 输出计算结果
```
## 二进制除法
二进制除法可以使用位运算中的右移运算（>>）和按位与运算（&）实现。假设需要对两个二进制数a和b进行除法运算，可以使用如下代码：
```java
int quotient = 0; // 商
int remainder = a; // 余数
while (remainder >= b) {
int shift = 0; // 移位数
while ((b << shift) <= remainder) { // 找到最大的移位数
shift++;
}
shift--; // 因为最后一次移位是多余的，所以需要减去1
quotient += (1 << shift); // 将移位数加到商中
remainder -= (b << shift); // 减去移位后的值
}
System.out.println(quotient); // 输出商
```

# Java里int类型的2到16进制表示方法

在Java中，整型字面量可以使用多种进制表示法，包括二进制、八进制和十六进制。以下是对应的表示方法：

二进制：以 0b 或 0B 开头，后面跟随一串 0 和 1 的数字序列，例如 0b1010 表示十进制的 10。

八进制：以 0 开头，后面跟随一串 0 到 7 的数字序列，例如 012 表示十进制的 10。

十六进制：以 0x 或 0X 开头，后面跟随一串 0 到 9 和 A 到 F 的数字序列，例如 0xA 表示十进制的 10。

需要注意的是，这些表示方法只适用于整型字面量。如果需要将其他类型的数据转换为整型，可以使用相应的转换函数，例如 Integer.parseInt(string, radix) 方法将字符串按指定进制转换为整型。

以下是一些示例：
```java
int a = 0b1010;  // 二进制表示的 10
int b = 012;     // 八进制表示的 10
int c = 0xA;     // 十六进制表示的 10
int d = 15;      // 十进制表示的 15，可以省略前缀

String hexStr = "1A"; 
int e = Integer.parseInt(hexStr, 16); // 将十六进制字符串转换为整型
```
需要注意的是，在编写代码时，尽量避免使用八进制表示法，因为容易与十进制混淆，导致代码难以理解和维护。

# 基础算法

## 快排
```java
public void quickSort(int[] nums, int left, int right) {
    if (left >= right) { // 如果数组为空或只有一个元素，直接返回
        return;
    }

    int pivot = partition(nums, left, right); // 选择基准元素，分割数组
    quickSort(nums, left, pivot-1); // 递归地对左子数组进行快速排序
    quickSort(nums, pivot+1, right); // 递归地对右子数组进行快速排序
}

private int partition(int[] nums, int left, int right) {
    int pivot = nums[left]; // 选择第一个元素作为基准元素
    int i = left + 1; // i 指向左侧已处理好的最后一个元素
    for (int j = i; j <= right; j++) {
        if (nums[j] < pivot) { // 如果当前元素小于基准元素，将其交换到左侧已处理好的部分
            swap(nums, i, j);
            i++;
        }
    }
    swap(nums, left, i-1); // 将基准元素和左侧已处理好的最后一个元素交换
    return i-1; // 返回基准元素的位置
}

private void swap(int[] nums, int i, int j) {
    int temp = nums[i];
    nums[i] = nums[j];
    nums[j] = temp;
}
```
## 归并排序
```java
public void mergeSort(int[] nums, int left, int right) {
    if (left >= right) { // 如果数组为空或只有一个元素，直接返回
        return;
    }

    int mid = (left + right) / 2; // 将数组二分，找到中间位置
    mergeSort(nums, left, mid); // 递归地对左子数组进行归并排序
    mergeSort(nums, mid+1, right); // 递归地对右子数组进行归并排序
    merge(nums, left, mid, right); // 合并左右两个子数组
}

private void merge(int[] nums, int left, int mid, int right) {
    int[] temp = new int[right-left+1]; // 临时数组，用于存放合并后的结果
    int i = left; // 左子数组的起始位置
    int j = mid+1; // 右子数组的起始位置
    int k = 0; // 临时数组的起始位置
    while (i <= mid && j <= right) {
        if (nums[i] < nums[j]) { // 如果左子数组的当前元素小于右子数组的当前元素，将左子数组的当前元素复制到临时数组中
            temp[k] = nums[i];
            k++;
            i++;
        } else { // 否则，将右子数组的当前元素复制到临时数组中
            temp[k] = nums[j];
            k++;
            j++;
        }
    }
    while (i <= mid) { // 复制左子数组中剩余的元素到临时数组中
        temp[k] = nums[i];
        k++;
        i++;
    }
    while (j <= right) { // 复制右子数组中剩余的元素到临时数组中
        temp[k] = nums[j];
        k++;
        j++;
    }
    // 将临时数组中的元素复制回原数组中
    for (int x = 0; x < temp.length; x++) {
        nums[left+x] = temp[x];
    }
}
```
## 桶排序

桶排序是一种线性排序算法，它的基本思想是利用桶（Bucket）来辅助排序。具体实现中，将待排序的元素按照大小分到不同的桶中，然后对每个桶中的元素进行排序，最后遍历所有的桶，依次将其中的元素放回原数组中，从而完成排序。

以下是使用最简洁的代码实现的桶排序算法：
```java
public void bucketSort(int[] nums, int bucketSize) {
 if (nums.length == 0) { // 如果数组为空，直接返回
        return;
    }

    int minValue = nums[0];
    int maxValue = nums[0];
    for (int i = 1; i < nums.length; i++) { // 找到数组中的最小值和最大值
        if (nums[i] < minValue) {
            minValue = nums[i];
        } else if (nums[i] > maxValue) {
            maxValue = nums[i];
        }
    }

    int bucketCount = (maxValue - minValue) / bucketSize + 1; // 计算需要的桶的数量
    List<List<Integer>> buckets = new ArrayList<>();
    for (int i = 0; i < bucketCount; i++) { // 创建空桶
        buckets.add(new ArrayList<>());
    }

    for (int i = 0; i < nums.length; i++) { // 将元素分配到不同的桶中
        int bucketIndex = (nums[i] - minValue) / bucketSize;
        buckets.get(bucketIndex).add(nums[i]);
    }

    int index = 0;
    for (List<Integer> bucket : buckets) { // 对每个桶中的元素进行排序，并放回原数组中
        int[] temp = new int[bucket.size()];
        for (int i = 0; i < bucket.size(); i++) {
            temp[i] = bucket.get(i);
        }
        Arrays.sort(temp);
        for (int i = 0; i < temp.length; i++) {
            nums[index++] = temp[i];
        }
    }
}
```
其中，bucketSort() 方法实现了桶排序的主要逻辑，首先判断数组是否为空，如果是则直接返回；然后找到数组中的最小值和最大值，计算需要的桶的数量，并创建空桶；接下来将元素分配到不同的桶中；最后对每个桶中的元素进行排序，并放回原数组中。

以上代码的时间复杂度为 O(n + klogk)，其中 n 是数组长度，k 是桶的数量。空间复杂度为 O(n + k)，其中 n 是数组长度，k 是桶的数量。

## 二分查找
```java
public int binarySearch(int[] nums, int target) {
    int left = 0; // 左边界
    int right = nums.length - 1; // 右边界
    while (left <= right) {
        int mid = (left + right) / 2; // 中间位置
        if (nums[mid] == target) { // 找到了目标元素，返回其下标
            return mid;
        } else if (nums[mid] < target) { // 如果中间元素小于目标元素，向右查找
            left = mid + 1;
        } else { // 否则，向左查找
            right = mid - 1;
        }
    }
    return -1; // 没有找到目标元素，返回 -1
}
```
## 回溯法

回溯法是一种基于搜索的算法，它通过不断地尝试从问题的所有解空间中搜索解来求解问题。具体实现中，回溯法通过深度优先搜索算法的方式，在解空间中搜索答案，并在搜索过程中剪枝，从而避免不必要的搜索，提高算法效率。

以下是使用最简洁的代码实现的回溯法算法：
```java
public void dfs(int[] nums, List<Integer> path, List<List<Integer>> res) {
    if (path.size() == nums.length) { // 如果路径长度等于数组长度，说明找到了一个解
        res.add(new ArrayList<>(path)); // 将路径加入结果集中
        return;
    }

    for (int i = 0; i < nums.length; i++) { // 遍历数组中的每个元素
        if (path.contains(nums[i])) { // 如果路径中已包含该元素，跳过
            continue;
        }
        path.add(nums[i]); // 将元素加入路径中
        dfs(nums, path, res); // 继续搜索
        path.remove(path.size()-1); // 回溯
    }
}
```
其中，dfs() 方法实现了回溯法的主要逻辑，首先判断路径长度是否等于数组长度，如果是，则说明找到了一个解，将路径加入结果集中，然后返回；否则，遍历数组中的每个元素，如果路径中已包含该元素，则跳过；否则，将元素加入路径中，继续搜索，搜索完成后需要回溯，将最后一个元素从路径中删除。

以上代码的时间复杂度和空间复杂度均与搜索的实现相关，具体取决于搜索的复杂度。

以下是一个 Java 实现的回溯法示例代码，通过该代码可以求解给定集合的所有子集：
```java
public class Main {
    /**
     * 递归实现回溯法，用于生成指定集合的所有子集
     *
     * @param nums 给定的集合
     * @return 返回指定集合的所有子集
     */
    public List<List<Integer>> subsets(int[] nums) {
        // 初始化结果集
        List<List<Integer>> res = new ArrayList<>();
        // 边界条件：如果数组为 null 或者空数组，则直接返回结果集
        if (nums == null || nums.length == 0) {
            return res;
        }
        // 启动回溯算法
        dfs(nums, 0, new ArrayList<>(), res);
        return res;
    }

    /**
     * 回溯算法，用于生成指定下标后的所有子集
     *
     * @param nums  给定的集合
     * @param index 指定的下标
     * @param curr  当前已选元素
     * @param res   所有解的集合
     */
    private void dfs(int[] nums, int index, List<Integer> curr, List<List<Integer>> res) {
        // 将当前已选元素加入结果集中
        res.add(new ArrayList<>(curr));
        /*
        从指定下标开始，依次选择剩余元素，并进行递归操作
        curr与i的状态：
        增删  curr    i
        +	[1]	0
        +	[1, 2]	1
        +	[1, 2, 3]	2
        -	[1, 2]	2
        -	[1]	1
        +	[1, 3]	2
        -	[1]	2
        -	[]	0
        +	[2]	1
        +	[2, 3]	2
        -	[2]	2
        -	[]	1
        +	[3]	2
        -	[]	2
         */
        for (int i = index; i < nums.length; i++) {
            curr.add(nums[i]); // 做出选择
            dfs(nums, i + 1, curr, res); // 递归处理剩余元素
            curr.remove(curr.size() - 1); // 撤销选择
        }
    }

    public static void main(String[] args) {
        int[] nums = {1, 2, 3};
        List<List<Integer>> res = new Main().subsets(nums);
        System.out.println(res);
    }
}
```
## 拓扑排序

拓扑排序是一种基于有向图的算法，它能够将有向无环图（DAG）中的节点按照一定的顺序排列。具体实现中，拓扑排序通过不断删除入度为 0 的节点，并对删除的节点的直接后继节点的入度减 1，从而逐步确定每个节点的顺序，直到所有节点都被确定为止。

以下是使用最简洁的代码实现的拓扑排序算法：
```java
public int[] topoSort(int numCourses, int[][] prerequisites) {
    int[] inDegrees = new int[numCourses]; // 统计每个节点的入度
    List<List<Integer>> adjacency = new ArrayList<>(); // 存储每个节点的后继节点
    for (int i = 0; i < numCourses; i++) {
        adjacency.add(new ArrayList<>()); // 初始化后继节点列表
    }
    for (int[] pre : prerequisites) {
        inDegrees[pre[0]]++; // 统计每个节点的入度
        adjacency.get(pre[1]).add(pre[0]); // 存储每个节点的后继节点
    }
    Queue<Integer> queue = new LinkedList<>(); // 存储入度为 0 的节点
    for (int i = 0; i < numCourses; i++) {
        if (inDegrees[i] == 0) {
            queue.offer(i);
        }
    }
    int[] res = new int[numCourses]; // 存储拓扑排序的结果
    int index = 0; // 记录拓扑排序的进度
    while (!queue.isEmpty()) {
        int curr = queue.poll(); // 获取入度为 0 的节点
        res[index++] = curr; // 将节点加入拓扑排序的结果中
        for (int next : adjacency.get(curr)) { // 遍历当前节点的后继节点
            inDegrees[next]--; // 将后继节点的入度减 1
            if (inDegrees[next] == 0) { // 如果后继节点的入度为 0，加入队列中
                queue.offer(next);
            }
        }
    }
    return index == numCourses ? res : new int[0]; // 如果拓扑排序完成，则返回结果；否则，返回空数组
}
```
其中，topoSort() 方法实现了拓扑排序的主要逻辑，首先统计每个节点的入度和后继节点，并将入度为 0 的节点加入队列中；然后依次从队列中取出节点，将其加入拓扑排序的结果中，并将其所有后继节点的入度减 1，如果有后继节点的入度为 0，则加入队列中；最后如果拓扑排序完成，则返回结果；否则，返回空数组。

以上代码的时间复杂度为 O(n + m)，其中 n 是节点的个数，m 是边的个数。空间复杂度为 O(n + m)，其中 n 是节点的个数，m 是边的个数。

以选课为例：
```java
public class Main {
    /**
     * 进行拓扑排序并返回一个拓扑序列
     *
     * @param n     节点总数
     * @param edges 边列表
     * @return 返回拓扑序列，如果不存在拓扑序列则返回空 List。
     */
    public List<Integer> topoSort(int n, int[][] edges) {
        // 构建邻接表和入度表
        List<List<Integer>> adj = new ArrayList<>(); // 邻接表
        int[] inDegrees = new int[n]; // 入度表
        for (int i = 0; i < n; i++) {
            adj.add(new ArrayList<>());
        }
        for (int[] edge : edges) {
            int u = edge[0], v = edge[1];
            adj.get(v).add(u); // 添加边 (v, u)
            inDegrees[u]++; // 更新入度表
        }
        // 创建队列并将所有入度为 0 的节点加入队列
        Queue<Integer> q = new LinkedList<>();
        for (int i = 0; i < n; i++) {
            if (inDegrees[i] == 0) {
                q.offer(i);
            }
        }
        // 完成拓扑排序过程
        List<Integer> res = new ArrayList<>(); // 记录拓扑序列的列表
        while (!q.isEmpty()) {
            int u = q.poll();
            res.add(u); // 将 u 加入拓扑序列
            List<Integer> outDegrees = adj.get(u);//获取所有的出度
            for (int v : outDegrees) {
                inDegrees[v]--; // 将 v 的入度减 1,找到入度为1的节点，就是最短边
                if (inDegrees[v] == 0) {
                    q.offer(v); // 如果 v 的入度为 0，则将其加入队列
                }
            }
        }
        // 判断是否存在拓扑序列
        if (res.size() != n) { // 如果拓扑序列长度小于节点总数，则说明存在环，无法完成排序
            return new ArrayList<>(); // 返回空列表表示不存在拓扑序列
        } else {
            return res; // 返回拓扑序列
        }
    }

    public static void main(String[] args) {
        int numCourses = 6;//课程数
        //课程关系：a依赖于b，可同时修
        int[][] prerequisites = {{1, 0}, {2, 0}, {3, 1}, {3, 2}, {4, 3}, {5, 4}};
        List<Integer> res = new Main().topoSort(numCourses, prerequisites);
        System.out.println(res);//[0, 1, 2, 3, 4, 5]
    }
}
```
## 反转链表
```java
public ListNode reverseList(ListNode head) {
    ListNode prev = null,ListNode curr = head;
    while (curr != null) { // 遍历链表
        ListNode next = curr.next; // 临时保存下一个结点的指针
        curr.next = prev; // 将当前结点的next指针指向前一个结点
        prev = curr; // 更新prev指针
        curr = next; // 更新curr指针
    }
    return prev; // 返回新的链表头结点
}
```

## 并查集
```java
class UnionFind {
    private int[] parent;

    public UnionFind(int n) {
        parent = new int[n];
        for (int i = 0; i < n; i++) {
            parent[i] = i;
        }
    }

    public int find(int x) {
        if (parent[x] != x) {
            parent[x] = find(parent[x]);
        }
        return parent[x];
    }

    public void union(int x, int y) {
        int rootX = find(x);
        int rootY = find(y);
        if (rootX != rootY) {
            parent[rootX] = rootY;
        }
    }

    public boolean isConnected(int x, int y) {
        return find(x) == find(y);
    }
}
```
在上面的代码中，我们定义了一个 UnionFind 类，主要提供了三个方法：find、union 和 isConnected。其中，find 方法用于查找 x 的祖先节点，union 方法用于将 x 和 y 所在的集合合并，isConnected 方法用于判断 x 和 y 是否在同一个集合中。

在 UnionFind 类的构造函数中，我们初始化了一个长度为 n 的 parent 数组，每个元素的初始值为自身的下标。在 find 方法中，我们通过递归的方式查找 x 的祖先节点，并将路径上的所有节点的父节点都指向祖先节点，以进行路径压缩，优化并查集的查询效率。在 union 方法中，我们先查找 x 和 y 的祖先节点，如果它们不属于同一个集合，则将其中一个节点的祖先节点指向另一个节点的祖先节点，以合并集合。在 isConnected 方法中，我们判断 x 和 y 是否属于同一个集合，即它们的祖先节点是否相同。

以朋友圈为例：
- 假设有 n 个人，其中某些人之间存在朋友关系，现在给定若干个询问，每个询问包含两个人的编号，需要判断这两个人是否属于同一个朋友圈内。
```java
public class Solution {
    public static void main(String[] args) {
        Solution solution = new Solution();
        int[][] m = {{1, 1, 0}, {1, 1, 0}, {0, 0, 1}};
        System.out.println(solution.findCircleNum(m)); // 输出 2

        int[][] m2 = {{1, 1, 0}, {1, 1, 1}, {0, 1, 1}};
        System.out.println(solution.findCircleNum(m2)); // 输出 1
    }

    // 定义并查集类
    class UnionFind {
        private int[] parent; // 记录父亲节点

        // 初始化并查集，初始状态下每个节点的父亲节点都是自己
        public UnionFind(int n) {
            parent = new int[n];
            for (int i = 0; i < n; i++) {
                parent[i] = i;
            }
        }

        // 查找节点 x 的根节点
        public int find(int x) {
            if (parent[x] != x) { // 如果当前节点不是根节点
                parent[x] = find(parent[x]); // 将节点的父节点指向根节点，同时进行路径压缩
            }
            return parent[x]; // 返回根节点
        }

        // 合并两个连通块
        public void union(int x, int y) {
            int rootX = find(x); // 找到节点 x 的根节点
            int rootY = find(y); // 找到节点 y 的根节点
            if (rootX != rootY) { // 如果两个节点不在同一个连通块中
                parent[rootX] = rootY; // 将节点 x 的根节点连接到节点 y 的根节点上
            }
        }

        // 判断两个节点是否在同一个连通块中
        public boolean connected(int x, int y) {
            int rootX = find(x); // 找到节点 x 的根节点
            int rootY = find(y); // 找到节点 y 的根节点
            return rootX == rootY; // 如果两个节点的根节点相同，则它们在同一个连通块中
        }
    }

    public int findCircleNum(int[][] m) {
        int n = m.length;
        UnionFind uf = new UnionFind(n); // 初始化并查集
        for (int i = 0; i < n; i++) { // 构建初始状态下的连通块
            for (int j = i + 1; j < n; j++) {
                if (m[i][j] == 1) {
                    uf.union(i, j);
                }
            }
        }
        int count = 0;
        for (int i = 0; i < n; i++) {
            if (uf.find(i) == i) { // 如果节点 i 是根节点，说明它所在的连通块还没有被统计过
                count++; // 连通块数加 1
            }
        }
        return count;
    }
}
```

## DFS 和 BFS
```java
// DFS
public void dfs(TreeNode root) {
    if (root == null) {
        return;
    }
    // 访问当前节点
    System.out.print(root.val + " ");
    // 遍历左子树
    dfs(root.left);
    // 遍历右子树
    dfs(root.right);
}
```

```java
// BFS
public void bfs(TreeNode root) {
    if (root == null) {
        return;
    }
    Queue<TreeNode> queue = new LinkedList<>();
    queue.offer(root);
    while (!queue.isEmpty()) {
        int size = queue.size();
        for (int i = 0; i < size; i++) {
            TreeNode node = queue.poll();
            // 访问当前节点
            System.out.print(node.val + " ");
            // 将当前节点的左右子节点加入队列
            if (node.left != null) {
                queue.offer(node.left);
            }
            if (node.right != null) {
                queue.offer(node.right);
            }
        }
    }
}
```

## 双向BFS
用 Java 实现双向 BFS 并打好注释的例子：
```java
import java.util.*;

public class BiDirectionalBFS {
    public static int biDirectionalBFS(String beginWord, String endWord, List<String> wordList) {
        // 判断目标单词是否在字典中
        if (!wordList.contains(endWord)) {
            return 0;
        }

        // 定义起点集合和终点集合
        Set<String> beginSet = new HashSet<>();
        Set<String> endSet = new HashSet<>();

        beginSet.add(beginWord);
        endSet.add(endWord);

        // 定义字典和访问记录
        Set<String> wordSet = new HashSet<>(wordList);
        Set<String> visited = new HashSet<>();

        int level = 1;
        while (!beginSet.isEmpty() && !endSet.isEmpty()) {
            // 优先扩展节点少的集合，减小时间复杂度
            if (beginSet.size() > endSet.size()) {
                Set<String> temp = beginSet;
                beginSet = endSet;
                endSet = temp;
            }

            Set<String> nextLevelSet = new HashSet<>();
            for (String word : beginSet) {
                char[] chars = word.toCharArray();
                for (int i = 0; i < chars.length; i++) {
                    char originalChar = chars[i];

                    for (char j = 'a'; j <= 'z'; j++) {
                        if (j == originalChar) {
                            continue;
                        }

                        chars[i] = j;
                        String nextWord = new String(chars);

                        if (endSet.contains(nextWord)) {
                            return level + 1;
                        }

                        if (wordSet.contains(nextWord) && !visited.contains(nextWord)) {
                            nextLevelSet.add(nextWord);
                            visited.add(nextWord);
                        }
                    }

                    chars[i] = originalChar;
                }
            }

            beginSet = nextLevelSet;
            level++;
        }

        return 0;
    }

    public static void main(String[] args) {
        String beginWord = "hit";
        String endWord = "cog";
        List<String> wordList = new ArrayList<>(Arrays.asList("hot", "dot", "dog", "lot", "log", "cog"));

        int length = biDirectionalBFS(beginWord, endWord, wordList);
        System.out.println("The shortest transformation sequence length is " + length); // Output: 5
    }
}
```
在上面的代码中，我们使用了双向 BFS 来实现了单词接龙问题。具体实现方式如下：

定义一个 biDirectionalBFS 方法，该方法接收三个参数，分别为起始单词 beginWord、目标单词 endWord 和单词字典 wordList。返回一个整数，表示起始单词到目标单词的最短距离。

判断目标单词是否在字典中，如果不在，则无法从起点到达终点，返回 0。

定义起点集合 beginSet 和终点集合 endSet，将起点和目标点分别放入两个集合中。

定义单词字典 wordSet 和访问记录 visited。

定义变量 level，表示当前遍历的层数，初始化为 1。

使用 while 循环，当起点集合和终点集合都不为空时进行循环。

为了减小时间复杂度，优先扩展节点少的集合。

定义一个 nextLevelSet 集合，将下一层的节点存储在其中。

对于起点集合中的每个单词，枚举所有可替换的位置和可替换的字符，生成下一个单词。如果下一个单词在终点集合中，则返回当前层数 level+1。

如果下一个单词在单词字典中且未被访问过，则将其加入 nextLevelSet 集合和 visited 集合中。

将 beginSet 设置为 nextLevelSet，表示下一层的节点。

将 level 增加 1。

如果没有找到目标单词，则返回 0。

## 剪枝
剪枝算法是指在搜索问题的过程中，通过某种策略减少搜索空间，从而提高搜索效率的一类算法。对于一个搜索问题，通常存在着众多的可能性，而其中大部分都是无用的，甚至会导致无限递归或超时等问题。剪枝算法的目的就是要尽可能地排除这些无用的可能性，达到快速、准确地求解问题的目的。

在实际应用中，剪枝算法通常会与其他算法结合使用，如回溯算法、动态规划等。剪枝算法的具体实现方式多种多样，常见的剪枝策略包括：最优性剪枝、可行性剪枝、对称性剪枝、重复性剪枝等。不同的剪枝策略可以针对不同的问题，采用不同的方法进行实现。

剪枝算法在实际应用中具有广泛的应用，如在图像识别、自然语言处理、游戏策略等领域中都有重要的地位。


以 N 皇后问题为例：
```java
public List<List<String>> solveNQueens(int n) {
    List<List<String>> res = new ArrayList<>();
    char[][] board = new char[n][n];
    for (int i = 0; i < n; i++) {
        Arrays.fill(board[i], '.');
    }
    dfs(board, 0, res);
    return res;
}

private void dfs(char[][] board, int row, List<List<String>> res) {
    if (row == board.length) {
        res.add(construct(board));
        return;
    }
    for (int col = 0; col < board.length; col++) {
        if (isValid(board, row, col)) {
            board[row][col] = 'Q';
            dfs(board, row + 1, res);
            board[row][col] = '.';
        }
    }
}

private boolean isValid(char[][] board, int row, int col) {
    // 检查列是否合法
    for (int i = 0; i < row; i++) {
        if (board[i][col] == 'Q') {
            return false;
        }
    }
    // 检查左上方是否有皇后
    for (int i = row - 1, j = col - 1; i >= 0 && j >= 0; i--, j--) {
        if (board[i][j] == 'Q') {
            return false;
        }
    }
    // 检查右上方是否有皇后
    for (int i = row - 1, j = col + 1; i >= 0 && j < board.length; i--, j++) {
        if (board[i][j] == 'Q') {
            return false;
        }
    }
    return true;
}

private List<String> construct(char[][] board) {
    List<String> res = new ArrayList<>();
    for (int i = 0; i < board.length; i++) {
        res.add(new String(board[i]));
    }
    return res;
}
```
在上面的代码中，我们定义了一个 solveNQueens 方法，用于求解 N 皇后问题，并返回所有合法的解。在 solveNQueens 方法中，我们首先创建了一个 n*n 的字符数组 board，将其所有元素初始化为 '.'。然后通过 dfs 方法，不断枚举每一行的皇后放置位置，并根据 isValid 方法判断当前位置是否合法（即是否与已有皇后在同一列或同一对角线上）。如果当前位置合法，则将其标记为 'Q'，并继续递归处理下一行。如果当前位置不合法，则跳过该位置，继续处理下一个位置。当处理完所有行时，将所有合法的解保存到 res 中，并返回。

在 isValid 方法中，我们通过三个循环分别判断当前位置是否与已有皇后在同一列或同一对角线上。通过这种方式，可以对搜索过程进行剪枝，减小搜索空间，避免不必要的计算。

## 约瑟夫环
f(n,m) = (f(n-1,m)+m) % n

其中，n 表示总人数，m 表示报数的阈值，f(n,m) 表示最终出圈的人的编号，编号从 0 开始。例如，f(5,3) 表示 5 个人围成一圈，每报数到 3 的人出圈，最终出圈顺序为 2 -> 0 -> 4 -> 1，因此 f(5,3) 的值为 2。

该公式的含义是，当有 n 个人围成一圈时，如果我们已经知道了 n-1 个人时的出圈顺序 f(n-1,m)，则当第 n 个人出圈后，剩余的 n-1 个人中编号为 (f(n-1,m)+m)%n 的人就是出圈的人。
```java
public int lastRemaining(int n, int m) {
    // 初始化出圈的第一个人的编号为 0
    int ans = 0;
    // 从第 2 个人开始遍历
    for (int i = 2; i <= n; i++) {
        // 根据公式 f(n,m) = (f(n-1,m)+m) % n 计算出圈的人的编号
        ans = (ans + m) % i;
    }
    // 返回最终留下的人的编号
    return ans;
}
```

## 查找回文串
```java
public List<String> findPalindromes(String s) {
    List<String> res = new ArrayList<>();
    for (int i = 0; i < s.length(); i++) {
        // 以字符为中心的回文串
        findPalindrome(s, i, i, res);
        // 以两个相邻字符为中心的回文串
        findPalindrome(s, i, i + 1, res);
    }
    return res;
}

private void findPalindrome(String s, int left, int right, List<String> res) {
    while (left >= 0 && right < s.length() && s.charAt(left) == s.charAt(right)) {
        // 找到一个回文串，加入结果集中
        res.add(s.substring(left, right + 1));
        // 继续扩展左右指针，查找更多回文串
        left--;
        right++;
    }
}
```

## 背包问题
背包问题是一类常见的动态规划问题，可以分为 01 背包、完全背包、多重背包和混合背包四种。

以 01 背包问题为例，题目描述如下：

有一个容量为 V 的背包和 n 种物品，每种物品有一个重量 w[i] 和一个价值 v[i]。现在需要从这 n 种物品中选择若干个放入背包中，使得在不超过容量 V 的情况下，放入背包中的物品总价值最大。

下面是 01 背包问题的动态规划实现：
```java
public int knapsack(int V, int[] w, int[] v) {
    int n = w.length;
    int[][] dp = new int[n+1][V+1];
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= V; j++) {
            if (w[i-1] > j) {
                dp[i][j] = dp[i-1][j];
            } else {
                dp[i][j] = Math.max(dp[i-1][j], dp[i-1][j-w[i-1]]+v[i-1]);
            }
        }
    }
    return dp[n][V];
}
```
其中，dp[i][j] 表示前 i 个物品放入容量为 j 的背包中所能获得的最大价值。

初始情况下，当 i = 0 或 j = 0 时，所有的 dp[i][j] 都为 0。

对于前 i 个物品，我们可以分为两种情况：

如果第 i 个物品的重量 w[i-1] 大于容量 j，那么第 i 个物品不能放入背包中，当前状态的最优解为 dp[i-1][j]。

如果第 i 个物品的重量 w[i-1] 不大于容量 j，那么当前状态的最优解为 dp[i-1][j] 和 dp[i-1][j-w[i-1]]+v[i-1] 中的最大值。其中 dp[i-1][j] 表示不放第 i 个物品所能获得的最大价值，dp[i-1][j-w[i-1]]+v[i-1] 表示放第 i 个物品所能获得的最大价值。

最终的答案为 dp[n][V]，即前 n 个物品放入容量为 V 的背包中所能获得的最大价值。

时间复杂度为 O(nV)，空间复杂度为 O(nV)。可以通过空间优化将空间复杂度优化到 O(V)。

## 打家劫舍
```java
public int rob(int[] nums) {
    if (nums == null || nums.length == 0) {
        return 0;
    }
    int n = nums.length;
    if (n == 1) {
        return nums[0];
    }
    int[] dp = new int[n];
    dp[0] = nums[0];
    dp[1] = Math.max(nums[0], nums[1]);
    for (int i = 2; i < n; i++) {
        dp[i] = Math.max(dp[i - 2] + nums[i], dp[i - 1]);
    }
    return dp[n - 1];
}
```

## 田忌赛马
```java
public int tianjiWins(int[] tianji, int[] qiwang) {
    // 将田忌和齐王所拥有的马按速度从小到大排序
    Arrays.sort(tianji);
    Arrays.sort(qiwang);
    int n = tianji.length;
    int tianjiIndex = 0, qiwangIndex = 0;
    int wins = 0;
    // 使用指针 tianjiIndex 和 qiwangIndex 分别指向田忌和齐王当前出战的马
    while (tianjiIndex < n && qiwangIndex < n) {
        /*
         田忌当前最快的马可以胜过齐王当前最慢的马，直接胜利
         如果田忌当前最慢的马可以胜过齐王当前最慢的马，出战最慢的马
         */
        if (tianji[tianjiIndex] > qiwang[qiwangIndex] || tianji[tianji.length - 1] > qiwang[qiwangIndex]) {
            wins++;
        }
        tianjiIndex++;
        qiwangIndex++;
    }
    // 返回田忌最终获得的胜利数
    return wins;
}
```
## 前缀树
```java
class TrieNode {
    // 每个节点包含一个哈希表，用于存储子节点
    HashMap<Character, TrieNode> children = new HashMap<>();
    // 表示当前节点是否是一个单词的结尾
    boolean isEndOfWord = false;
}

class Trie {
    private TrieNode root;

    public Trie() {
        // 初始化根节点
        root = new TrieNode();
    }

    public void insert(String word) {
        TrieNode current = root;
        // 遍历单词中的每个字符，如果该字符不存在于当前节点的子节点中，则创建一个新的节点
        for (char c : word.toCharArray()) {
            if (!current.children.containsKey(c)) {
                current.children.put(c, new TrieNode());
            }
            // 将 current 指向新创建的节点，继续遍历下一个字符
            current = current.children.get(c);
        }
        // 遍历完单词后，将当前节点标记为单词的结尾
        current.isEndOfWord = true;
    }

    public boolean search(String word) {
        TrieNode current = root;
        // 遍历单词中的每个字符，如果该字符不存在于当前节点的子节点中，则单词不存在于前缀树中
        for (char c : word.toCharArray()) {
            if (!current.children.containsKey(c)) {
                return false;
            }
            // 将 current 指向下一个节点，继续遍历下一个字符
            current = current.children.get(c);
        }
        // 如果遍历完单词后，当前节点已经标记为单词的结尾，则单词存在于前缀树中
        return current.isEndOfWord;
    }

    public boolean startsWith(String prefix) {
        TrieNode current = root;
        // 遍历前缀中的每个字符，如果该字符不存在于当前节点的子节点中，则前缀不存在于前缀树中
        for (char c : prefix.toCharArray()) {
            if (!current.children.containsKey(c)) {
                return false;
            }
            // 将 current 指向下一个节点，继续遍历下一个字符
            current = current.children.get(c);
        }
        // 如果遍历完前缀后，前缀存在于前缀树中
        return true;
    }
}
```
## 大根堆和小根堆
大根堆和小根堆都是一种基于堆的数据结构，它们主要用于维护一组数据中的最大值和最小值。具体来说，大根堆是一种完全二叉树，其中每个节点的值都大于等于其子节点的值；小根堆也是一种完全二叉树，其中每个节点的值都小于等于其子节点的值。

大根堆和小根堆都有一个堆顶元素，堆顶元素是当前堆中的最大值或最小值。我们可以使用堆的操作（如插入、删除堆顶、获取堆顶等）来维护堆中的元素，并且这些操作的时间复杂度都是 O(log n)。
```java
// 创建一个大根堆
PriorityQueue<Integer> maxHeap = new PriorityQueue<>(Collections.reverseOrder());
// 创建一个小根堆
PriorityQueue<Integer> minHeap = new PriorityQueue<>();
```
## 记忆化搜素
使用了记忆化搜索的方式实现了斐波那契数列。具体实现方式如下：
```java
// 定义一个哈希表，用于存储已经计算的结果
static HashMap<Integer, Integer> memo = new HashMap<>();

/*
1.定义一个 memo 哈希表，用于存储已经计算的结果。
2.定义一个 fib 方法，该方法接收一个整数 n，表示要计算斐波那契数列中第 n 个数的值。
3.在 fib 方法中，首先判断 memo 中是否已经存在 n 的计算结果，如果存在，则直接返回结果。
4.如果 n 小于 2，则特殊处理，直接返回 n 的值。
5.否则，递归计算斐波那契数列中第 n 个数的值，并将结果存入 memo 哈希表中。
6.在 main 方法中，调用 fib 方法计算斐波那契数列中第 10 个数的值，并将结果输出。
通过使用记忆化搜索的方式，我们可以避免重复计算，并且减少时间复杂度，是一种高效的实现方式。
 */
public static int fib(int n) {
    // 如果已经计算过该值，则直接返回结果
    if (memo.containsKey(n)) {
        return memo.get(n);
    }

    int res;
    // 对于斐波那契数列中的前两个数特殊处理
    if (n < 2) {
        res = n;
    } else {
        // 否则递归计算斐波那契数列中第 n 个数的值
        res = fib(n - 1) + fib(n - 2);
    }

    // 将结果存入哈希表中
    memo.put(n, res);
    return res;
}
```

## 单调栈
单调栈是一种特殊的栈，它的特点是栈中元素具有单调性。具体来说，单调栈中的元素单调递增或单调递减，通常使用单调递增栈和单调递减栈来解决一些算法问题。

单调栈的常见应用场景包括：

寻找下一个更大的元素：给定一个数组，要求对于每个元素，找出它后面第一个比它大的元素。

寻找下一个更小的元素：给定一个数组，要求对于每个元素，找出它后面第一个比它小的元素。

求解滑动窗口最大值/最小值：给定一个数组和一个固定大小的窗口，要求每次移动窗口后，求出窗口内的最大值/最小值。

单调栈可以通过维护一个单调递增或单调递减的栈来解决这些问题，具体实现方式如下：

对于寻找下一个更大/更小的元素问题，使用单调递增栈或单调递减栈来维护一个单调栈。当遍历到一个新的元素时，将栈中比它小/大的元素全部弹出，直到栈为空或栈顶元素不小于/大于当前元素。

对于求解滑动窗口最大值/最小值问题，同样可以使用单调递增或单调递减栈来维护一个单调栈。当遍历到一个新的元素时，先将该元素加入栈中。然后判断栈顶元素是否已经滑出窗口，如果是，则将其弹出。最后，取栈顶元素即为当前窗口的最大值/最小值。

通过使用单调栈，我们可以在 O(n) 的时间复杂度内解决一些算法问题，是一种高效的实现方式。

以下是一个用 Java 实现单调栈并打好注释的例子：
```java
import java.util.*;

public class MonotonicStack {
    public static int[] nextGreaterElement(int[] nums) {
        int n = nums.length;
        int[] res = new int[n];
        Arrays.fill(res, -1);
        // 定义一个单调递减栈，存储元素下标
        Deque<Integer> stack = new ArrayDeque<>();

        for (int i = 0; i < n; i++) {
            // 如果当前元素大于栈顶元素，说明当前元素是栈顶元素的下一个更大元素
            while (!stack.isEmpty() && nums[i] > nums[stack.peek()]) {
                int index = stack.pop();
                res[index] = nums[i];
            }
            // 将当前元素下标入栈
            stack.push(i);
        }

        return res;
    }

    public static void main(String[] args) {
        int[] nums = {2, 1, 2, 4, 3};
        int[] res = nextGreaterElement(nums);
        System.out.println(Arrays.toString(res)); // Output: [4, 2, 4, -1, 4]
    }
}
```

通过使用单调递减栈，我们可以在 O(n) 的时间复杂度内解决寻找下一个更大元素的问题，是一种高效的实现方式。

## 数位DP
```java
import java.util.*;

public class DigitDP {
    public static int countNumbersWithUniqueDigits(int n) {
        // 特判
        if (n == 0) {
            return 1;
        }
        // dp[i] 表示 i 位数中不含重复数字的数的个数
        int[] dp = new int[n + 1];
        // 初始化
        dp[0] = 1;
        int preSum = 9;
        // 数位 DP
        for (int i = 1; i <= n; i++) {
            dp[i] = dp[i - 1] + preSum;
            preSum *= (10 - i);
        }
        return dp[n];
    }

    public static void main(String[] args) {
        int n = 2;
        int count = countNumbersWithUniqueDigits(n);
        System.out.println("There are " + count + " numbers with unique digits in " + n + " digits."); // Output: There are 91 numbers with unique digits in 2 digits.
    }
}
```
在上面的代码中，我们使用了数位 DP 来计算不同位数内数字不重复的数的个数。具体实现方式如下：

定义一个 countNumbersWithUniqueDigits 方法，该方法接收一个整数 n，表示数位的位数。返回一个整数，表示不同位数内数字不重复的数的个数。

如果 n 为 0，直接返回 1。

定义一个 dp 数组，其中 dp[i] 表示 i 位数中不含重复数字的数的个数。

初始化 dp[0] 为 1，表示 0 位数中不含重复数字的数的个数为 1。

定义一个变量 preSum，表示之前状态的和。

通过数位 DP，依次计算 dp[1]、dp[2]、...、dp[n] 的值。

对于 dp[i]，可以通过 dp[i-1] 和 preSum 计算得到，其中 preSum 表示 i 位数中不含重复数字的数的和，初始化为 9，之后乘上递减的 10-i，计算出所有 i 位数中不含重复数字的数的个数之和。

最后返回 dp[n]，即为所求的答案。

通过使用数位 DP，我们可以在 O(n) 的时间复杂度内解决不同位数内数字不重复的数的个数问题，是一种高效的实现方式。

## 线段树
```java
import java.util.*;

public class SegmentTree {
    // 定义一个 SegmentTreeNode 类表示线段树节点
    static class SegmentTreeNode {
        int start;
        int end;
        int sum;
        SegmentTreeNode left;
        SegmentTreeNode right;

        public SegmentTreeNode(int start, int end) {
            this.start = start;
            this.end = end;
            this.sum = 0;
            this.left = null;
            this.right = null;
        }
    }

    // 定义一个 build 方法来构建线段树
    public static SegmentTreeNode build(int[] nums, int start, int end) {
        if (start > end) {
            return null;
        }
        SegmentTreeNode root = new SegmentTreeNode(start, end);
        if (start == end) {
            root.sum = nums[start];
        } else {
            int mid = start + (end - start) / 2;
            root.left = build(nums, start, mid);
            root.right = build(nums, mid + 1, end);
            root.sum = root.left.sum + root.right.sum;
        }
        return root;
    }

    // 定义一个 update 方法来更新线段树
    public static void update(SegmentTreeNode root, int index, int value) {
        if (root.start == index && root.end == index) {
            root.sum = value;
        } else {
            int mid = root.start + (root.end - root.start) / 2;
            if (index <= mid) {
                update(root.left, index, value);
            } else {
                update(root.right, index, value);
            }
            root.sum = root.left.sum + root.right.sum;
        }
    }

    // 定义一个 sumRange 方法来查询线段树的区间和
    public static int sumRange(SegmentTreeNode root, int start, int end) {
        if (root.start == start && root.end == end) {
            return root.sum;
        } else {
            int mid = root.start + (root.end - root.start) / 2;
            if (end <= mid) {
                return sumRange(root.left, start, end);
            } else if (start > mid) {
                return sumRange(root.right, start, end);
            } else {
                return sumRange(root.left, start, mid) + sumRange(root.right, mid + 1, end);
            }
        }
    }

    public static void main(String[] args) {
        int[] nums = {1, 3, 5, 7, 9, 11};
        SegmentTreeNode root = build(nums, 0, nums.length - 1);
        int sum = sumRange(root, 1, 4);
        System.out.println("The sum of elements in the range [1, 4] is " + sum); // Output: The sum of elements in the range [1, 4] is 24

        update(root, 2, 0);
        sum = sumRange(root, 1, 4);
        System.out.println("After updating, the sum of elements in the range [1, 4] is " + sum); // Output: After updating, the sum of elements in the range [1, 4] is 16
    }
}
```
在上面的代码中，我们使用了线段树来实现区间查询和单点更新。具体实现方式如下：

定义了一个 SegmentTreeNode 类，表示线段树节点。其中包含四个属性：起始位置 start，结束位置 end，区间和 sum，以及左右孩子节点 left 和 right。

定义了一个 build 方法来构建线段树。该方法接收一个整数数组 nums，以及线段树的起始位置 start 和结束位置 end。返回构建好的线段树的根节点。

如果 start 大于 end，直接返回 null。

构建根节点 root，如果 start 等于 end，则说明该节点是叶子节点，将 sum 赋值为 nums[start]。否则，将数组 nums 分成两半，递归构建左右子树，并计算出根节点的区间和。

定义了一个 update 方法来更新线段树。该方法接收线段树的根节点 root、需要更新的索引 index，以及更新的值 value。

如果当前节点是叶子节点，则将 sum 赋值为 value。否则，计算出当前节点的中。

## 欧拉回路
欧拉回路是指在一个无向图中，从某个顶点开始，沿着边依次遍历每个节点，最终回到起点的一条路径。该路径经过图中每个边恰好一次。

换句话说，欧拉回路是一种特殊的回路，它覆盖了图中的所有边，且每条边仅经过一次。
```java
import java.util.*;

public class EulerCircuit {
    public static boolean hasEulerCircuit(int[][] graph) {
        // 相邻节点度数为奇数的数量
        int oddCount = 0;
        for (int i = 0; i < graph.length; i++) {
            int degree = 0;
            for (int j = 0; j < graph[0].length; j++) {
                degree += graph[i][j];
            }
            if (degree % 2 == 1) {
                oddCount++;
            }
        }
        // 如果相邻节点度数为奇数的数量为 0 或 2，则存在欧拉回路
        return oddCount == 0 || oddCount == 2;
    }

    public static void main(String[] args) {
        int[][] graph1 = {{0, 1, 1}, {1, 0, 1}, {1, 1, 0}};
        boolean hasCircuit = hasEulerCircuit(graph1);
        System.out.println("Graph 1 has Euler circuit: " + hasCircuit); // Output: Graph 1 has Euler circuit: true

        int[][] graph2 = {{0, 1, 1}, {1, 0, 0}, {1, 0, 0}};
        hasCircuit = hasEulerCircuit(graph2);
        System.out.println("Graph 2 has Euler circuit: " + hasCircuit); // Output: Graph 2 has Euler circuit: false
    }
}
```

在上面的代码中，我们使用了相邻节点度数的奇偶性来判断一个无向图中是否存在欧拉回路。具体实现方式如下：

定义一个 hasEulerCircuit 方法，该方法接收一个二维数组 graph，表示输入的无向图。返回一个布尔值，表示该图中是否存在欧拉回路。

定义一个变量 oddCount，表示相邻节点度数为奇数的数量，初始值为 0。

遍历 graph 中的每一个节点，计算其度数，如果度数为奇数，则将 oddCount 加 1。

如果相邻节点度数为奇数的数量为 0 或 2，则存在欧拉回路，返回 true；否则不存在欧拉回路，返回 false。

最后在 main 函数中，我们分别对两个无向图 graph1 和 graph2 进行判断，输出判断结果。

通过使用相邻节点度数的奇偶性，我们可以在 O(n^2) 的时间复杂度内判断一个无向图中是否存在欧拉回路，是一种高效的实现方式。





